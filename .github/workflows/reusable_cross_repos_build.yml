name: Reusable trigger of building cross multiple repositories
on:
  workflow_call:
jobs:
  setup:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write
      pull-requests: write
      packages: read
    if: ${{ github.event.issue.pull_request && contains(github.event.comment.body, 'build_prs') }}
    container:
      image: ghcr.io/${{ github.repository_owner }}/kernel:latest
      credentials:
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Notify job started
        uses: actions/github-script@v8
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `Job is started, see ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}.`
            })
      - name: Create patches directory
        run: |
          mkdir -p patches
      - name: Download patches
        id: fetch_prs
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs').promises;
            const body = context.payload.comment.body;
            const prRegex = /https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/g;
            let match;
            let prs = [];
            let patchUrls = [];
            let fetchedPrs = [];
            while ((match = prRegex.exec(body)) !== null) {
              let owner = match[1];
              let repo = match[2];
              let prNum = match[3];
              prs.push({owner: owner, repo: repo, pr_num: prNum});
              patchUrls.push({repo: repo, url: match[0] + ".diff"});
            }
            // Get metadata of the PR.
            await Promise.all(prs.map(async({ owner, repo, pr_num }) => {
              const { data: pullRequest } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pr_num,
              });
              fetchedPrs.push({owner: owner, repo: repo, pr_num: pr_num, sha: pullRequest.head.sha});
            }));
            // Download diffs.
            await Promise.all(patchUrls.map(async ({ repo, url }) => {
              console.log(`Downloading ${url}`);
              const patchFilename = `patches/${repo}.diff`;
              const response = await github.request({
                url: url,
              });
              await fs.writeFile(patchFilename, response.data);
            }));
            core.setOutput('fetched_prs', JSON.stringify(fetchedPrs));
      - name: Init repo and sync
        run: |
          repo init --depth=1 -u https://github.com/vivoblueos/manifests.git -b main -m manifest.xml
          repo sync -j$(nproc)
      - name: Apply patches
        run: |
          set -e
          set -x
          for patch in patches/*.diff; do
            patch_abspath=$(realpath ${patch})
            repo=$(basename ${patch} ".diff")
            if [ "${repo}" != "manifests" ]; then
              cd ${repo}
            else
              cd .repo/${repo}
            fi
            git apply -3 --check --verbose ${patch_abspath} && git apply -3 --verbose ${patch_abspath}
            if [ $? != 0 ]; then
              exit 1
            fi
            cd - > /dev/null
          done
      - name: Re-sync repos
        # In case manifests repo is changed.
        run: |
          repo sync -j$(nproc)
      - name: Upload workspace
        uses: actions/upload-artifact@v4
        with:
          name: workspace
          path: .
          include-hidden-files: true
  check_format:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      contents: read
      checks: write
      packages: read
    container:
      image: ghcr.io/${{ github.repository_owner }}/kernel:latest
      credentials:
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Download workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .
      - name: Check format
        uses: actions/github-script@v8
        with:
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            const path = require('path');
            // Get list of patch files
            const patchesDir = 'patches';
            const patchFiles = fs.readdirSync(patchesDir).filter(f => f.endsWith('.diff'));
            if (patchFiles.length === 0) {
              console.log('No patch files found for format check');
              return;
            }
            let formatErrors = [];
            let totalCheckedFiles = 0;
            for (const patchFile of patchFiles) {
              const repo = patchFile.replace(/\.diff$/, '');
              // Handle manifests repo special case
              if (repo === 'manifests') {
                continue;
              }
              let repoPath = repo;
              console.log(`\nChecking format in repo: (${repoPath})`);
              // Check if repo directory exists
              if (!fs.existsSync(repoPath)) {
                console.log(`Repo directory ${repoPath} not found, skipping`);
                continue;
              }
              // Get modified files from patch file content
              let modifiedFiles = [];
              try {
                const patchContent = fs.readFileSync(path.join(patchesDir, patchFile), 'utf-8');
                const patchLines = patchContent.split('\n');
                // Extract file paths from patch headers (+++ b/filename)
                modifiedFiles = patchLines
                  .filter(line => line.startsWith('+++ b/'))
                  .map(line => line.substring(6)) // Remove '+++ b/' prefix
                  .filter(file => file && file.length > 0)
                  .filter(file => {
                    const ext = path.extname(file).toLowerCase();
                    return ext === '.yml' || ext === '.yaml' || ext === '.gn' || ext === '.gni' || ext === '.py' || ext === '.rs';
                  });
                console.log(`Found ${modifiedFiles.length} modified files in patch for ${repo}:`);
                modifiedFiles.forEach(file => console.log(`  - ${file}`));
              } catch (error) {
                console.log(`Error reading patch file ${patchFile}: ${error.message}`);
                continue;
              }

              if (modifiedFiles.length === 0) {
                console.log(`No relevant files found in patch for ${repo}`);
                continue;
              }
              // Check format for each modified file
              for (const file of modifiedFiles) {
                const filePath = path.resolve(repoPath, file);
                const ext = path.extname(file).toLowerCase();
                // Skip if file doesn't exist
                if (!fs.existsSync(filePath)) {
                  console.log(`File ${filePath} doesn't exist, skipping`);
                  continue;
                }
                console.log(`Checking format for: ${filePath}`);
                try {
                  if (ext === '.gn' || ext === '.gni') {
                    console.log(`Checking GN format for: ${filePath}, ext: ${ext}`);
                    const out = execSync(`gn format --dry-run \"${filePath}\"`, {
                      encoding: 'utf-8',
                      stdio: ['inherit', 'pipe', 'pipe']
                    });
                    if (out.trim()) {
                      formatErrors.push(`GN formatting issue in ${filePath}:\n${out}`);
                    }
                  } else if (ext === '.py') {
                    console.log(`Checking Python format for: ${filePath}`);
                    const out = execSync(`yapf3 -d \"${filePath}\"`, {
                      encoding: 'utf-8',
                      stdio: ['inherit', 'pipe', 'pipe']
                    });
                    if (out.trim()) {
                      formatErrors.push(`Python formatting issue in ${filePath}:\n${out}`);
                    }
                  } else if (ext === '.rs') {
                    console.log(`Checking Rust format for: ${filePath}`);
                    const out = execSync(`rustfmt --edition=2021 --check --unstable-features --skip-children \"${filePath}\"`, {
                      encoding: 'utf-8',
                      stdio: ['inherit', 'pipe', 'pipe']
                    });
                    if (out.trim()) {
                      formatErrors.push(`Rust formatting issue in ${filePath}:\n${out}`);
                    }
                  } else if (ext === '.yml' || ext === '.yaml') {
                    console.log(`Checking YAML format for: ${filePath}`);
                    const out = execSync(`yamlfmt -lint \"${filePath}\"`, {
                      encoding: 'utf-8',
                      stdio: ['inherit', 'pipe', 'pipe']
                    });
                    if (out.trim()) {
                      formatErrors.push(`YAML formatting issue in ${filePath}:\n${out}`);
                    }
                  }
                  totalCheckedFiles++;
                } catch (error) {
                  // Check if it's a formatting error or other error
                  const output = (error.stdout || '') + (error.stderr || '');
                  if (output.includes('format') || output.includes('Format')) {
                    formatErrors.push(`Formatting issue in ${repo}/${file}:\n${output}`);
                  } else {
                    console.log(`Skipping format check for ${repo}/${file}: ${error.message}`);
                  }
                }
              }
            }

            console.log(`\nTotal files checked: ${totalCheckedFiles}`);
            if (formatErrors.length > 0) {
              console.log('❌ Format check failed:');
              formatErrors.forEach(error => console.log(error));
              core.setFailed('Format check failed');
              process.exit(1);
            } else {
              console.log('✅ All modified files pass format check');
            }
  check_license:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      contents: read
      checks: write
      packages: read
    container:
      image: ghcr.io/${{ github.repository_owner }}/kernel:latest
      credentials:
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Download workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .
      - name: Check license
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const patchesDir = 'patches';
            let failedRepos = [];
            let checkedRepos = [];

            // Find all .diff files in patches/
            const patchFiles = fs.readdirSync(patchesDir).filter(f => f.endsWith('.diff'));

            for (const patchFile of patchFiles) {
              const repo = patchFile.replace(/\.diff$/, '');
              let repoPath = repo;
              // Skip invalid repos for license check
              if (repo.includes('manifests') || repo.includes('libc') || repo.includes('book') || repo.includes('external')) {
                console.log(`Skipping ${repo} for license check.`);
                continue;
              }

              try {
                // Run license-eye header check in each repo directory
                const originalCwd = process.cwd();
                process.chdir(repoPath);
                // Print the contents of the .licenserc.yaml file in the repo directory (if present)
                const licenseRcFile = '.licenserc.yaml';
                if (fs.existsSync(licenseRcFile)) {
                  console.log(`--- .licenserc.yaml in ${repoPath} ---`);
                } else {
                  console.log(`No .licenserc.yaml found in ${repoPath}`);
                  continue;
                }
                const result = execSync('license-eye header check', {
                  encoding: 'utf-8',
                  stdio: ['inherit', 'pipe', 'pipe']
                });
                process.chdir(originalCwd);
                if (result.includes('ERROR one or more files does not have a valid license header')) {
                  console.log(`License issue in ${repoPath}:\n${result}`);
                  failedRepos.push(repoPath);
                }
              } catch (e) {
                // Always log output for diagnosis
                const out = (e.stdout ? e.stdout.toString() : '') + (e.stderr ? e.stderr.toString() : '');
                if (out.includes('ERROR one or more files does not have a valid license header')) {
                  console.log(`License issue in ${repoPath}:\n${out}`);
                  failedRepos.push(repoPath);
                } else {
                  console.log(`Error running license-eye in ${repoPath}:\n${out}`);
                  failedRepos.push(repoPath);
                }
              }
            }

            if (failedRepos.length > 0) {
              core.setFailed(`❌ License header issues found in these repos: ${failedRepos.join(', ')}`);
              process.exit(1);
            } else if (checkedRepos.length === 0) {
              console.log('✅ No repos to check license for.');
            } else {
              console.log('✅ All checked repos have valid license headers!');
            }
  build_host:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      contents: read
      checks: write
      packages: read
    container:
      image: ghcr.io/${{ github.repository_owner }}/kernel:latest
      credentials:
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Download workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .
      - name: Build and test kernel for host
        uses: actions/github-script@v8
        with:
          script: |
            const { execSync } = require('child_process');

            const board = 'none';
            const configs = [
              { name: 'debug', build_type: 'debug', direct_syscall_handler: 'false' },
              { name: 'release', build_type: 'release', direct_syscall_handler: 'false' }
            ];

            for (const config of configs) {
              console.log(`\nBuilding ${board} ${config.name} version...`);

              const outDir = `out/${board}.${config.name}`;
              const args = `board="${board}" build_type="${config.build_type}" direct_syscall_handler=${config.direct_syscall_handler}`;

              try {
                // Generate build files
                console.log(`Running: gn gen ${outDir} --args='${args}'`);
                execSync(`gn gen ${outDir} --args='${args}'`, { stdio: 'inherit' });

                // Build and test
                console.log(`Running: ninja -C ${outDir} check_all`);
                execSync(`ninja -C ${outDir} check_all`, { stdio: 'inherit' });

                console.log(`✅ ${board} ${config.name} build completed successfully`);
              } catch (error) {
                console.error(`❌ ${board} ${config.name} build failed:`, error.message);
                process.exit(1);
              }
            }
  build_and_check_virtual_boards:
    runs-on: ubuntu-latest
    needs: setup
    permissions:
      contents: read
      checks: write
      packages: read
    container:
      image: ghcr.io/${{ github.repository_owner }}/kernel:latest
      credentials:
        username: ${{ github.repository_owner }}
        password: ${{ secrets.GITHUB_TOKEN }}
    strategy:
      matrix:
        board: [qemu_mps2_an385, qemu_mps3_an547, qemu_riscv64, qemu_virt64_aarch64, qemu_riscv32]
        build_type: [release, debug]
        syscall_mode: [swi, dsc]
    steps:
      - name: Download workspace
        uses: actions/download-artifact@v4
        with:
          name: workspace
          path: .
      - name: Build and test kernel for ${{ matrix.board }}.${{ matrix.build_type }}.${{ matrix.syscall_mode }}
        uses: actions/github-script@v8
        env:
          BOARD: '${{ matrix.board }}'
          BUILD_TYPE: '${{ matrix.build_type }}'
          SYSCALL_MODE: '${{ matrix.syscall_mode }}'
        with:
          script: |
            const { execSync } = require('child_process');
            const board = process.env.BOARD;
            const buildType = process.env.BUILD_TYPE;
            const syscallMode = process.env.SYSCALL_MODE;
            const profile = `${board}.${buildType}.${syscallMode}`;
            const outDir = `out/${profile}`;
            const isDirectSyscall = syscallMode === 'dsc';
            const args = `board="${board}" build_type="${buildType}" direct_syscall_handler=${isDirectSyscall}`;
            try {
                // Generate build files.
                console.log(`Running: gn gen ${outDir} --args='${args}'`);
                execSync(`gn gen ${outDir} --args='${args}'`, { stdio: 'inherit' });

                // Build and test.
                console.log(`Running: ninja -C ${outDir} check_all`);
                execSync(`ninja -C ${outDir} check_all`, { stdio: 'inherit' });

                console.log(`✅ ${profile} build completed successfully`);
            } catch (error) {
                console.error(`❌ ${profile} build failed:`, error.message);
                process.exit(1);
            }
  notify:
    runs-on: ubuntu-latest
    needs: [setup, check_format, check_license, build_host, build_and_check_virtual_boards]
    if: always()
    permissions:
      contents: read
      checks: write
      pull-requests: write
    steps:
      - name: Notify job ended
        uses: actions/github-script@v8
        with:
          script: |
            // Check if any job failed
            const jobStatuses = {
              setup: "${{ needs.setup.result }}",
              check_format: "${{ needs.check_format.result }}",
              check_license: "${{ needs.check_license.result }}",
              build_host: "${{ needs.build_host.result }}",
              build_and_check_virtual_boards: "${{ needs.build_and_check_virtual_boards.result }}",
            };
            // Debug: Log all job statuses
            console.log('Job statuses:', JSON.stringify(jobStatuses, null, 2));
            const failedJobs = Object.entries(jobStatuses)
              .filter(([job, status]) => {
                const isFailed = status === 'failure' || status === 'cancelled';
                if (isFailed) {
                  console.log(`Job ${job} failed with status: ${status}`);
                }
                return isFailed;
              })
              .map(([job, status]) => `${job} (${status})`);
            const skippedJobs = Object.entries(jobStatuses)
              .filter(([job, status]) => {
                const isSkipped = status === 'skipped';
                if (isSkipped) {
                  console.log(`Job ${job} was skipped with status: ${status}`);
                }
                return isSkipped;
              })
              .map(([job, status]) => `${job} (${status})`);
            console.log(`Failed jobs: ${failedJobs.length}, Skipped jobs: ${skippedJobs.length}`);
            let statusMessage;
            let sign;
            if (failedJobs.length > 0) {
              sign = '❌';
              statusMessage = `Job failed. Failed jobs: ${failedJobs.join(', ')}`;
              if (skippedJobs.length > 0) {
                statusMessage += `. Skipped jobs: ${skippedJobs.join(', ')}`;
              }
            } else if (skippedJobs.length > 0) {
              sign = '⚠️';
              statusMessage = `Job completed with skipped jobs: ${skippedJobs.join(', ')}`;
            } else {
              sign = '✅';
              statusMessage = 'All jobs completed successfully';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `${sign} ${statusMessage}, see ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}.`
            })
